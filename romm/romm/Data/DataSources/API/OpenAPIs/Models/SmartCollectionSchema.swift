//
// SmartCollectionSchema.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct SmartCollectionSchema: Codable, JSONEncodable {

    public nonisolated(unsafe) static let romIdsRule = ArrayRule(minItems: nil, maxItems: nil, uniqueItems: true)
    public var name: String
    public var description: String? = ""
    public var romIds: Set<Int>
    public var romCount: Int
    public var pathCoverSmall: String?
    public var pathCoverLarge: String?
    public var pathCoversSmall: [String]
    public var pathCoversLarge: [String]
    public var isPublic: Bool? = false
    public var isFavorite: Bool? = false
    public var isVirtual: Bool? = false
    public var isSmart: Bool? = true
    public var createdAt: Date
    public var updatedAt: Date
    public var id: Int
    public var filterCriteria: [String: Any]
    public var filterSummary: String
    public var userId: Int
    public var userUsername: String

    public init(name: String, description: String? = "", romIds: Set<Int>, romCount: Int, pathCoverSmall: String?, pathCoverLarge: String?, pathCoversSmall: [String], pathCoversLarge: [String], isPublic: Bool? = false, isFavorite: Bool? = false, isVirtual: Bool? = false, isSmart: Bool? = true, createdAt: Date, updatedAt: Date, id: Int, filterCriteria: [String: Any], filterSummary: String, userId: Int, userUsername: String) {
        self.name = name
        self.description = description
        self.romIds = romIds
        self.romCount = romCount
        self.pathCoverSmall = pathCoverSmall
        self.pathCoverLarge = pathCoverLarge
        self.pathCoversSmall = pathCoversSmall
        self.pathCoversLarge = pathCoversLarge
        self.isPublic = isPublic
        self.isFavorite = isFavorite
        self.isVirtual = isVirtual
        self.isSmart = isSmart
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.id = id
        self.filterCriteria = filterCriteria
        self.filterSummary = filterSummary
        self.userId = userId
        self.userUsername = userUsername
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case description
        case romIds = "rom_ids"
        case romCount = "rom_count"
        case pathCoverSmall = "path_cover_small"
        case pathCoverLarge = "path_cover_large"
        case pathCoversSmall = "path_covers_small"
        case pathCoversLarge = "path_covers_large"
        case isPublic = "is_public"
        case isFavorite = "is_favorite"
        case isVirtual = "is_virtual"
        case isSmart = "is_smart"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case id
        case filterCriteria = "filter_criteria"
        case filterSummary = "filter_summary"
        case userId = "user_id"
        case userUsername = "user__username"
    }

    // Decodable protocol methods
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        description = try container.decodeIfPresent(String.self, forKey: .description) ?? ""
        romIds = try container.decode(Set<Int>.self, forKey: .romIds)
        romCount = try container.decode(Int.self, forKey: .romCount)
        pathCoverSmall = try container.decodeIfPresent(String.self, forKey: .pathCoverSmall)
        pathCoverLarge = try container.decodeIfPresent(String.self, forKey: .pathCoverLarge)
        pathCoversSmall = try container.decode([String].self, forKey: .pathCoversSmall)
        pathCoversLarge = try container.decode([String].self, forKey: .pathCoversLarge)
        isPublic = try container.decodeIfPresent(Bool.self, forKey: .isPublic) ?? false
        isFavorite = try container.decodeIfPresent(Bool.self, forKey: .isFavorite) ?? false
        isVirtual = try container.decodeIfPresent(Bool.self, forKey: .isVirtual) ?? false
        isSmart = try container.decodeIfPresent(Bool.self, forKey: .isSmart) ?? true
        createdAt = try container.decodeFlexibleDate(forKey: .createdAt)
        updatedAt = try container.decodeFlexibleDate(forKey: .updatedAt)
        id = try container.decode(Int.self, forKey: .id)
        // Handle [String: Any] as a simple JSON object with string keys and any values
        // For now, we'll decode it as [String: String] and cast to [String: Any]
        let stringDict = try container.decodeIfPresent([String: String].self, forKey: .filterCriteria) ?? [:]
        filterCriteria = stringDict.mapValues { $0 as Any }
        filterSummary = try container.decode(String.self, forKey: .filterSummary)
        userId = try container.decode(Int.self, forKey: .userId)
        userUsername = try container.decode(String.self, forKey: .userUsername)
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(romIds, forKey: .romIds)
        try container.encode(romCount, forKey: .romCount)
        try container.encode(pathCoverSmall, forKey: .pathCoverSmall)
        try container.encode(pathCoverLarge, forKey: .pathCoverLarge)
        try container.encode(pathCoversSmall, forKey: .pathCoversSmall)
        try container.encode(pathCoversLarge, forKey: .pathCoversLarge)
        try container.encodeIfPresent(isPublic, forKey: .isPublic)
        try container.encodeIfPresent(isFavorite, forKey: .isFavorite)
        try container.encodeIfPresent(isVirtual, forKey: .isVirtual)
        try container.encodeIfPresent(isSmart, forKey: .isSmart)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(id, forKey: .id)
        // Convert [String: Any] to [String: String] for encoding
        let stringFilterCriteria = filterCriteria.compactMapValues { value -> String? in
            if let stringValue = value as? String {
                return stringValue
            }
            return String(describing: value)
        }
        try container.encode(stringFilterCriteria, forKey: .filterCriteria)
        try container.encode(filterSummary, forKey: .filterSummary)
        try container.encode(userId, forKey: .userId)
        try container.encode(userUsername, forKey: .userUsername)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension SmartCollectionSchema: Identifiable {}
